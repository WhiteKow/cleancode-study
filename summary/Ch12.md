## **Ch 12. Emergence**

### **생각 공유**

**`@ChanhuiSeok`**

12장 창발성
창발성? 정말 처음 듣는 단어였다.
켄트 벡이 제시한 단순한 설계 규칙 4가지가 소프트웨어 설계 품질을 크게 높여준다고 믿는다. (아래는 중요도 순)

- 모든 테스트를 실행한다.
- 중복을 없앤다.
- 프로그래머 의도를 표현한다.
- 클래스와 메서드 수를 최소로 줄인다.

- 모든 테스트를 실행한다. → 테스트를 철저히 거쳐 모든 테스트 케이스를 항상 통과하는 시스템은 테스트 가능한 시스템이여 당연하지만 중요한 말이다. SRP를 준수하는 클래스는 테스트가 훨씬 더 쉽다. 결합도가 높으면 테스트 케이스를 작성하기 어렵다.
✏️ 책에서는 테스트 케이스를 만들고 계속 돌리는 과정 속에서 시스템이 낮은 결합도와 높은 응집력을 갖는 방향으로 자연스럽게 간다는 말을 하고싶은 것 같다.
- 리팩터링 → 테스트 케이스를 모두 작성한 다음에야 코드와 클래스를 정리해도 괜찮다. 코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다. 테스트 케이스가 있기 때문이다.
    - 리팩터링 단계에서는 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하는 등 다양한 기법을 동원한다. 중복을 제거하고 프로그래머 의도를 표현하고 클래스와 메서드 수를 최소로 줄이는 단계이기도 하다.
- 중복을 없애라 : 깔끔한 시스템을 만들려면 단 몇 줄이라도 중복을 제거하겠다는 의지가 필요하다.
  - 같은 코드를 여기저기 쓰지 말자. 중복되는 부분을 새 함수로 추상화하고, 이것을 다른 맥락에서 재사용할 수 있는 기회를 제공할 수 있다. 이러한 소규모 재사용은 시스템 복잡도를 극적으로 줄여주며, 소규모 재사용을 제대로 익혀야 대규모 재사용이 가능하다.
  - `Template Method` 패턴 : 눈에 들어오는 중복을 제거하기 위함이다. 그리고 하위 클래스는 중복되지 않은 정보만 제공할 때 사용하는 패턴 → 중복되는 기능을 상위 클래스에서 정의, 확장이나 중복되지 않은 부분만 서브 클래스에서 구현
- 표현하라 : 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어가지만… 이 시스템 자체가 복잡해지면 점점 유지보수 개발자는 시스템 이해에 보내는 시간만 늘어나고, 코드를 오해할 가능성이 커진다. 그러므로, 코드는 개발자의 의도를 분명하게 표현해야 한다. `만들 때부터 읽기 쉽게 만들려는 충분한 고민을 반드시 하자.`
    - 좋은 이름을 선택하자.
    - 함수와 클래스 크기는 가능한 줄이자.
    - 표준 명칭을 사용하자. (예: 디자인 패턴 사용 시 클래스 이름에 표준 패턴 이름을 넣는 등)
    - 단위 테스트 케이스를 꼼꼼히 작성하자.

- 클래스와 메서드 수를 최소한으로 줄이자. ✏️ 이 규칙은 다른 설계 규칙 네개 중 우선순위가 가장 낮다. 물론 중요하지만 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다는 의미이다.

---

**`@jjangsungwon`** 

### 느낀 점
- 창발성의 정의와는 다른 내용이 많은 것 같다. 처음 혹은 새롭게 밝혀내는게 창발성인데 기존에 있는 설계 원칙을 지켜라는 내용이 대부분이었다. 물론 기존 설계 원칙에 좋은 내용은 많았다. 특히 중요도 순으로 설명한 켄트 벡의 네가지 설계 원칙이 기억에 남는다. (창발성 챕터인데 이게 기억에 남는게 맞는지 모르겠다..?)

#### 창발성
- 남이 모르거나 하지 않는 것을 처음으로 또는 새롭게 밝혀내거나 이루어 내는 성질

#### 켄트 벡의 네가지 설계 원칙 (중요도 순)
- 모든 테스트를 실행한다.
- 중복을 없앤다.
- 프로그래머 의도를 표현한다.
- 클래스와 메서드 수를 최소로 줄인다.

#### 모든 테스트를 실행한다.
- 무엇보다 먼저, 설계는 의도한 대로 돌아가는 시스템을 내놓아야 한다. 맞는 말이다. 하지만, 실패한 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다는 TDD 첫 번째 원칙과 뭔가 안맞는 듯한 느낌이 든다.
- 결합도가 높으면 테스트 케이스를 작성하기 어렵다. 함수 안에 함수를 호출하는 경우 테스트 케이스를 작성하기 어려웠다. 결국 깔끔한 테스트 코드를 작성하지 못했다. 하지만, 함수 안에서 다른 함수를 호출할 수 밖에 없는 구조였기 때문에 어쩔 수 없는 결합이었다고 생각함.

#### 중복을 없애라
- 깔끔한 시스템을 만들려면 단 몇 줄이라도 중복을 제거하겠다는 의지가 필요함
- 최근 이정도는 괜찮겠지하고 넘어갔었는데 반성하자,,

#### 표현하라
- 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.
- 개발자가 코드를 명백하게 짤수록 다른 사람이 그 코드를 이해하기 쉬워진다. 그래야 결함이 줄어들고 유지보수 비용이 적게 든다.
- 좋은 이름 선택, 함수와 클래스 크기 줄이기, 표준 명칭 사용, 단위 테스트 케이스 꼼꼼히 작성
- 나중에 코드를 읽을 사람은 바로 자신일 가능성이 높다는 사실을 명심하자. 본인이 짠 코드를 나중에 봤을 때 이해못하는 경우도 많음

---

**`@qrlagusdn`** 
## 테스트

### 모든 테스트를 실행한다

## 리팩터링

### 중복을 없앤다

### 프로그래머 의도를 표현한다

### 클래스와 메서드 수를 최소로 줄인다

위의 4가지 규칙을 적용한다면 설계는 단순해진다

- 테스트
    - 테스트를 철저히 거쳐서 모든 테스트 케이스를 항상 통과하는 시스템은 테스트가 가능한 시스템.
    - 결합도가 높으면 테스트 케이스 작성이 어려움
    - → 테스트 케이스를 많이 작성할 수록 자연스럽게 DIP, DI, interface, Abstraction 등 을 사용해서 결합도를 낮추게 됨
- 리팩터링
    - 테스트 케이스가 잘 되어있다면 리팩터링 및 기능 추가 또한 두렵지 않음
    - 중복 없애기
        - Template Method 패턴
            - 특정 작업을 처리하는 일부분을 서브 클래스로 캡슐화해서 전체적인 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내용만 바꾸는 패턴
            - 객체지향에서는 아주 일반적임
            
            ```java
            //추상 클래스 선생님
            abstract class Teacher{
                public void start_class() {
                    inside();
                    attendance();
                    teach();
                    outside();
                }
            	
                // 공통 메서드
                public void inside() {
                    System.out.println("선생님이 강의실로 들어옵니다.");
                }
                
                public void attendance() {
                    System.out.println("선생님이 출석을 부릅니다.");
                }
                
                public void outside() {
                    System.out.println("선생님이 강의실을 나갑니다.");
                }
                
                // 추상 메서드
                abstract void teach();
            }
             
            // 국어 선생님
            class Korean_Teacher extends Teacher{
                
                @Override
                public void teach() {
                    System.out.println("선생님이 국어를 수업합니다.");
                }
            }
             
            //수학 선생님
            class Math_Teacher extends Teacher{
            
                @Override
                public void teach() {
                    System.out.println("선생님이 수학을 수업합니다.");
                }
            }
            
            //영어 선생님
            class English_Teacher extends Teacher{
            
                @Override
                public void teach() {
                    System.out.println("선생님이 영어를 수업합니다.");
                }
            }
            
            public class Main {
                public static void main(String[] args) {
                    Korean_Teacher kr = new Korean_Teacher(); //국어
                    Math_Teacher mt = new Math_Teacher(); //수학
                    English_Teacher en = new English_Teacher(); //영어
                    
                    kr.start_class();
                    System.out.println("----------------------------");
                    mt.start_class();
                    System.out.println("----------------------------");
                    en.start_class();
                }
            }
            ```
            
    - 표현하기
        - 유지보수가 제일 코스트가 큼
        - 코드를 이해하기 쉽게 만들어야함
            - 좋은 이름
            - 함수와 클래스 크기 줄이기
            - 표준명칭
                - 클래스가 표준 패턴을 사용하여 구현된다면 클래스 이름에 패턴 이름을 넣어주기
                    - singleton, factory, facade … 등
            - 유닛 테스트 케이스 꼼꼼히 작성
            - 노오력
    - 클래스와 메서드 수를 최소로 줄여라
        - 중요하긴 하지만, 테스트 케이스 만들고 리펙터링 하는게 더 중요함
        - 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있음
---

### **회의록**

- **폴더 관리**
  - 프로젝트 루트 경로에 회의록 폴더(`summary`) 라고 만들고, 그 밑에 주마다 논의했던 내용을 작성해서 올린다. (서로 공유한 내용, 회의록 포함)
  - repo에 내용을 올릴 때는 main에 바로 push 한다. (따로 branch, PR 관리 X)

- **issue 탭 사용**
  - 구글밋 전에 한 주동안 스터디했던 장을 개인적으로 간단하게 정리해서 issue 탭에 올린다. (공유하고 싶은 내용이나 자료를 포함해도 괜찮다)
  - issue 탭에 올릴 때 타이틀은 `[Ch1] 챕터 제목 이름` 의 형태로 올린다.
  - 구글밋에서 각자 생각을 공유할 때 issue 탭에 작성한 것을 참고용으로 활용하면 좋겠다.
