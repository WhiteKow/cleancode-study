## **Ch6. 객체와 자료 구조(Objects and Data Structures)**

### **생각 공유**

**`@ChanhuiSeok`**

---

**`@jjangsungwon`** 

객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다. 상황에 따라 각각의 장단점이 분명히 드러난다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다고한다. 이 사실을 이해하는 것은 어렵지 않았다. 하지만, 직면한 문제에서 최적인 해결책을 선택하는 것은 쉬울까?

**객체**
- 동작을 공개하고 자료를 숨긴다.
- 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
- 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. (=기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기 쉽다)
- 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다. (=기존 객체에 새 동작을 추가하기는 어렵다)


**자료 구조**
- 별다른 동작 없이 자료를 노출한다.
- 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
- 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
- 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다.
<br>

**기차 충돌(train wreck)**
```java
(1)
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

(2)
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```
- (2) 코드를 통해 (1) 코드를 어느 정도 유추할 수 있다고 생각함. 
- 각각의 함수 반환 타입이 Options, File, String 이 아니라 모두 동일한 String 이였다면 저렇게 분리할 필요가 있었을까? 분리해서 얻는 이득이 무엇일까? 

---

**`@qrlagusdn`** 

---

